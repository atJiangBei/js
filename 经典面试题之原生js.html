<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<ul id="ul">
			<li>
				<button>1</button>
			</li>
			<li>
				<button>2</button>
			</li>
		</ul>
		<script>
			const ul = document.getElementById('ul')
			ul.onclick = function(e){
				console.log(e.target,e.currentTarget)
			}
		</script>
	</body>
</html>
<script>
	//1
	// var a = {
	// 	x:0,
	// 	toString(){
	// 		return ++this.x;
	// 	}
	// }
	// 
	// if(a == 1 && a == 2 && a == 3){
	// 	console.log("您好")
	// }

	// var a = {
	// 	x:0,
	// 	toString(){
	// 		return ++this.x;
	// 	}
	// }
	// 
	// if(a == 1 && a == 2 && a == 3){
	// 	console.log("您好")
	// }

	// var a = [1,2,3];
	// a.toString = a.shift;
	// if(a == 1 && a == 2 && a == 3){
	// 	console.log("您好")
	// }


	// var i = 0;
	// Object.defineProperty(window,'a',{
	// 	get(){
	// 		return ++i
	// 	}
	// })
	// 
	// if(a == 1 && a == 2 && a == 3){
	// 	console.log("您好")
	// }

	//去重
	// const arr = [1,1,2,2,3,4,1];
	// let len = arr.length;
	//  
	//     for(let i = 0; i < len; i++){
	//         for(let j = i + 1; j < len; j++){
	//             if(arr[i] === arr[j]){
	//                 arr.splice(j,1);
	//                 len--;
	//                 j--;
	//             }
	//         }
	//     }
	// 
	// console.log(arr)

	// const arr = [1,1,2,1,2,3,4,1,2,3,4,5];
	// const newArr = [];
	// let len = arr.length;
	//  
	//     for(i = 0; i < len; i++){
	//         for(j = i + 1; j < len; j++){
	//             if(arr[i] === arr[j]){
	// 				i++
	//             }
	// 			console.log(1)
	//         }
	//         newArr.push(arr[i]);
	//     }
	// 
	// console.log(newArr)

	// const arr = [1,2,3,4,4,5,3,4,2,2,3,4,2]
	// const newArr = []
	// 
	// arr.forEach(ele=>{
	// 	if(newArr.indexOf(ele)<0){
	// 		newArr.push(ele)
	// 	}
	// })
	// console.log(newArr)

	//冒泡排序
	// const arr = [1,10,2,3,7,6,5,8,4,8,10];
	// const newArr = [];
	// function cb(newArr,arr,fn){
	// 	if(!arr.length)return;
	// 	const result = fn.apply(null,arr)
	// 	arr.splice(arr.indexOf(result),1)
	// 	newArr.push(result)
	// 	cb(newArr,arr,fn)
	// }
	// cb(newArr,arr,Math.max)
	// console.log(newArr,arr)

	// const arr1 = [1,2,3,7,6,5,8,4,8];
	// const newArr1 = [];
	// cb(newArr1,arr1,Math.min)
	// console.log(newArr1,arr1)
	// console.log(Date.now())
	// const arr = [1,10,2,3,7,6,5,8,4,8,10];
	// for (let i=0;i<arr.length-1;i++) {
	// 	for (let j=i+1;j<arr.length;j++) {
	// 		if(arr[i]>arr[j]){
	// 			let n = arr[i]
	// 			arr[i] = arr[j]
	// 			arr[j] = n
	// 		}
	// 	}
	// }
	// console.log(arr)
	// console.log(Date.now())

	//NaN

	// console.log(isNaN(NaN))
	// console.log(Number.isNaN({}))
	// console.log(Number.isNaN(()=>{}))
	// console.log(Number.isNaN(undefined))
	// console.log(Number.isNaN())

	//ajax,手写一个简单的ajax请求

	const xhr = new XMLHttpRequest();
	/*
	xhr.readyState
	0: 请求未初始化
	1: 服务器连接已建立
	2: 请求已接收
	3: 请求处理中
	4: 请求已完成，且响应已就绪

	xhr.status
	200: "OK"
	404: 未找到页面
	*/

	/*xhr.onreadystatechange = function() { //当准备情况改变时触发事件
		if (xhr.readyState == 4 ) { //当准备情况为完成状态时
			if (xhr.status == 200) {//当返回的状态码为200（成功返回了数据）
				console.log(xhr.responseText)
			}
		}
	}
	xhr.onloadstart = function() {
		console.log('请求开始')
	}
	xhr.onerror = function() {
		console.log('请求出错')
	}
	xhr.onload = function() {
		console.log('请求完成')
	}
	xhr.onloadend = function() {
		//无论请求出错还是完成,只要结束,就触发此事件
		console.log('请求结束')
		console.log(xhr)
	}

	xhr.onprogress = function(event) {//接收期间数据持续不断出发
	//event.loaded=>已上传数据；//event.total=>数据总量；
	}
	
	xhr.onabort = function() {
		console.log('请求被中断')
	}
	xhr.ontimeout = function(){
		console.log('请求超时')
	}
	
	
	//method=>GET,POST
	//url=>地址
	//async 是否异步 true false 默认为true
	//xhr.open(method, url, async)
	xhr.open('GET', 'http://www.baidu.com', true)
	
	
	//发送数据
	//xhr.send(data)
	xhr.send({});
	
	//参数设置
	xhr.timeout = 10000;//超过此毫秒数,自动终止请求
	
	withCredentials = false;//默认false,是否Access-Control应使用cookie或授权标头之类的凭据发出跨站点请求。
	
	//方法
	xhr.abort()//如果请求已发送，则中止该请求。
	xhr.getAllResponseHeaders()//以字符串形式返回所有响应头，以CRLF分隔，或者null如果未接收到响应，则返回所有响应头。
	
	xhr.getResponseHeader()//返回包含指定标题的文本的字符串，或者返回null尚未接收到的响应或响应中不存在标题的字符串
	xhr.open()//初始化请求。
	
	xhr.overrideMimeType()//覆盖服务器返回的MIME类型。
	
	xhr.send()//发送请求。如果请求是异步的（默认设置），则此方法在发送请求后立即返回。
	
	xhr.setRequestHeader()//设置HTTP请求标头的值。您必须setRequestHeader()在之后open()但在之后致电send()。
	

	//参数返回
	xhr.readyState 
	//只读 返回unsigned short，请求状态。
	xhr.response
	//只读 返回ArrayBuffer，Blob，Document，JavaScript对象，或一个DOMString，这取决于的值xhr.responseType，即包含响应实体主体。
	xhr.responseText
	//只读 返回一个DOMString包含对请求的响应的文本形式的，或者null请求未成功发送或尚未发送。
	xhr.responseType
	//只读 是定义响应类型的枚举值。
	xhr.responseURL
	//只读 返回响应的序列化URL，如果URL为null，则返回空字符串。
	xhr.responseXML
	//只读 返回一个Document包含对请求的响应的，或者null如果请求不成功，尚未发送或无法将其解析为XML或HTML，则返回。在工人中不可用。
	xhr.status
	//只读 返回unsigned short带有请求响应状态的。
	xhr.statusText
	//只读 返回一个DOMString包含HTTP服务器返回的响应字符串的。与不同xhr.status，它包括响应消息的整个文本（200 OK例如“ ”）。
*/
</script>
<script>
	//函数不同的调用方式内部的this指向
	var a = 'a'
	var obj = {
		a:'aa',
		alert(){
			console.log(this.a)
		}
	}
	
	obj.alert();//aa
	
	const alert = obj.alert;
	alert();//a
	(0,obj.alert)()
</script>
