<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="index.js"></script>
	</head>
	<body>
	</body>
</html>
<script>
// const name = function(){
// 	
// }
// console.log(name.__proto__)
// console.log(name.__proto__ === Function.prototype)
// console.log(Function)
// console.log(Function.__proto__)
// console.log(Function.__proto__.__proto__)
// console.log(Function.prototype === Function.__proto__)
// console.log(Function.prototype.__proto__)
// 
// console.log(Array.__proto__)
// console.log(Array.prototype)
// console.log(Array.__proto__.__proto__)
</script>
<script>
	// 做一个构造函数A,作用是对data添加特性方法（set,get）
    class A {
      constructor(data, computed) {
        this.defineProperty(data, 'a',data.a) // 对data中的属性‘a’添加特性方法
        this.collect =  computed.computA, // computed中的函数,记录下来
          
        computed.computA() // 运行此函数，会对data.a 进行取值，触发data.a的get函数，建立依赖
      }

      defineProperty(obj, key, val) { // 使用函数封装 添加特性方法
        const collect = [] 
        Object.defineProperty(obj, key, {
          get:()=> {                    // 当取值 data.a 时会触发get函数
            if (this.collect && !collect.some(it => it === this.collect)) {
              collect.push(this.collect)  // 如果探测到有需要运行的compueted函数，搜集起来。
            }
            return val
          },
          set:value => {
            val = value
            collect.forEach(it => it())  // 如果data.a = 2 则运行set特性函数，此时，那些搜集起来的computed函数都运行
          }
        })
      }
    }




    const computed = {
      computA() {
　　　　　let result = data.a +1
　　　　　console.log(result) 
        return result
      }
    }

    const data = {
      a: 1
    }
  // 测试
    new A(data, computed) // 2
    data.a++ // 3
    data.a = 6 //7
	
</script>