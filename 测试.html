<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<input id="textbox" />
	</body>
</html>
<script>
	//  1,
	// pop  push shift  unshift  
	
	
	//2,
	const asyncFn = (times=1000)=>{
		return new Promise(res=>{
			setTimeout(res,1000)
		})
	}
	const proFn = async ()=>{
		await asyncFn(2000)
		console.log("2秒钟后输出",1)
	}
	//调用
	proFn()
	//3 
	
	// 1，componentWillMount   // 挂载前 
	// 2，componentDidMount   //挂载后
	// 3，componentWillReceiveProps (nextProps)  在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。
	// 4，shouldComponentUpdate(nextProps,nextState)   此声明周期一般做为优化时使用   
	//在此判断是否该继续渲染   每次更新state或者props时此处 返回 true则渲染重新走render函数  否则不做处理
	// 5，componentWillUpdate (nextProps,nextState)  组件更新前
	// 6，componentDidUpdate(prevProps,prevState)  组件更新后
	//  渲染函数
	//1，首次触发，2，每次的setState更新数据后触发   3，父组件传之props改变 触发 
	//render()
	
	
	/*
	4，
	*/
   const data = [
	   {name:"zhangsan",lang:"java"},
	   {name:"zhangsan",lang:"js"},
	   {name:"lisi",lang:"css"}
   ]
   const  copyData = (data)=>{
	   const obj = {};
	   for(let k in data){
	   		obj[k] = data[k]
	   }
	   return obj;
   }
   const mergeData = (...arg)=>{
	   let obj = null;
	   for(let i=0;i<arg.length;i++){
		   if(i == 0){
			   const data1 = arg[0]
			   obj = copyData(data1)
		   }else{
			   const data = copyData(arg[i]);
			   for(let k in obj){
				   if(data[k]){
					   if(Array.isArray(obj[k])){
						   obj[k].push(data[k])
					   }else{
						   if(obj[k] !== data[k]){
							   obj[k] = [obj[k],data[k]]
						   }
					   }
				   }
			   }
		   }
	   }
	   return obj
   }
   const filters = (name)=>{
	   return data.filter(item=>item.name === name)
   }
   const patchData = (data)=>{
	   return [...new Set(data.map(item=>item.name))]
	   .map(name=>{
		   return filters(name)
	   }).map(arr=>{
		   return  mergeData(...arr)
	   })
   }
   console.log(patchData(data))
   
/*
5,debounce

*/
function debonce(method,context){
	clearTimeout(method.tId)
	method.tId = setTimeout(function(){
		method.call(context)
	},300)
}
const textbox = document.getElementById("textbox");
function query(){
	//每次 停止输入后  300毫秒之后发出请求
	console.log(textbox.value);//此处模拟发送请求
}
textbox.oninput = function(){
	debonce(query)
}


/*
6
*/
/* 测试页面  暂时注释
import React,{useReducer} from 'react'

export default function ReducerDemo() {
    const [count, dispath] = useReducer((state,action)=> {
       switch(action.type){
           case 'add':
                return state + 1;
            case 'sub':
                return state - 1;
            default:
                return state;
       }
    }, 0);
    return (
        <div>
            <h1 className="title">{count}</h1>
            <button className="btn is-primary"
                onClick={()=> dispath({type:'add'})}
                >Increment</button>
            <button className="btn is-warnning"
                onClick={()=> dispath({type:'sub'})}
                >Decrement</button>
        </div>
    )
}

*/
</script>


<!-- [
	{name:"hehe",age:1,sex:"男"},
	{name:"hehe",age:2},
	{name:"hehe",child:"hehehe",age:3},
	{name:"haha",age:1}
]



[
	{name:"hehe",age:[1,2,3],sex:"男"，child:"hehehe"},
	{name:"haha",age:1}
] -->